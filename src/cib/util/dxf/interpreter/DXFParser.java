/* Generated By:JavaCC: Do not edit this line. DXFParser.java */
package cib.util.dxf.interpreter;

import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import cib.util.dxf.Attributes;
import cib.util.dxf.AttributesAdapter;
import cib.util.dxf.ContentHandler;
import cib.util.dxf.GroupCode;
import cib.util.dxf.QuitDXFParserException;

/** 
 * The DXF parser. Applications can quit DXF parsing by throwing the
 * QuitDXFParserException.
 *
 * @author Berthold Firmenich, Christian Koch
 * @version $Revision: 1296 $, $Author: svn-firmenich $
 * @version $Date: 2011-01-29 00:51:03 +0100 (Sat, 29 Jan 2011) $
 */

public class DXFParser implements DXFParserConstants {

        private ContentHandler m_ch = null;

        public static void main(String[] args) {
                // Usage
        if (args.length != 1) {
                System.out.println("Usage: DXFParser filename");
                System.exit(0);
        }

                // Open file
        FileInputStream myStream = null;
        try {
                myStream = new FileInputStream(new File(args[0]));
        }
        catch (IOException e) {
                System.out.println(e);
                System.exit(1);
        }

        // Parse file
        DXFParser myParser;
        myParser = new DXFParser(myStream);
        try {
                        myParser.start();
        }
        catch (TokenMgrError x) {
                System.out.println(x);
                System.exit(2);
        }
        catch (ParseException x) {
                System.out.println(x);
                System.exit(0);
        }
    }

    // Entity notification
    private String m_seqName = null;
        private void notifyEntity(AttributesAdapter attr) {
                // Check element type...
                String type = attr.getValue(GroupCode.GC0);

                // End of sequence?
                if (type.equals("SEQEND")) {
                        if (m_seqName == null)
                                throw new AssertionError("Unexpected SEQEND");
                        m_ch.endElement(m_seqName);
                        m_seqName = null;
                        return;
                }

                // Format element name
                String val5 = attr.valueExists(GroupCode.GC5) ?
                        attr.getValue(GroupCode.GC5) : "null";
                String name = type + "@" + val5;

                // Start of sequence?
                if (type.equals("POLYLINE")) {
                        if (m_seqName != null)
                                throw new AssertionError("Unexpected start of SEQ");
                        m_seqName = name;
                        m_ch.startElement(name, attr);
                        return;
                }
                else if (type.equals("INSERT")) {
                        if (m_seqName != null)
                                throw new AssertionError("Unexpected start of SEQ");
                        if (attr.valueExists(GroupCode.GC66)) {
                                String val66 = attr.getValue(GroupCode.GC66);
                                if (val66.endsWith("1")) {
                                        m_seqName = name;
                                        m_ch.startElement(name, attr);
                                        return;
                                }
                        }
                }

                // Ordinary element
                m_ch.startElement(name, attr);
                m_ch.endElement(name);
        }

        // Return the current content handler.
    public ContentHandler getContentHandler() {
        return m_ch;
    }

    // Allow an application to register a content event handler.
    public void setContentHandler(ContentHandler handler) {
        m_ch = handler;
    }

  final public void start() throws ParseException {
                try {
                        file();
                }
                //catch (QuitDXFParserException e) {
                //        {if (true) throw e;}
                //}
                catch (RuntimeException e) {
                        int line = token == null ? -1 : token.beginLine;
                        int column = token == null ? -1 : token.beginColumn;
                        String tokenImage = token == null ? "" : token.image;

                        StackTraceElement[]     ste = e.getStackTrace();
                        String steStr = " at\n";
                        for (int i = 0; i < ste.length; i++) {
                                steStr += "\t" + ste[i] + "\n";
                        }

                        {if (true) throw new ParseException("Error while parsing line " + line +
                                " and column " + column + ":\n" + tokenImage +
                                "\ngot a RuntimeException " + e + steStr);}
                }
  }

  final public void file() throws ParseException {
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SEC_START:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      jj_consume_token(SEC_START);
      section();
      jj_consume_token(SEC_END);
    }
    jj_consume_token(FILE_EOF);
  }

  final public void section() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case S_HEADER:
      sectionHeader();
      break;
    case S_CLASSES:
      sectionClasses();
      break;
    case S_TABLES:
      sectionTables();
      break;
    case S_BLOCKS:
      sectionBlocks();
      break;
    case S_ENTITIES:
      sectionEntities();
      break;
    case S_OBJECTS:
      sectionObjects();
      break;
    case S_THUMBS:
      sectionThumbs();
      break;
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

// Section HEADER --------------------------------------------------------------
  final public void sectionHeader() throws ParseException {
    jj_consume_token(S_HEADER);
                m_ch.startSection("HEADER");
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TOKEN_9:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_2;
      }
      variable();
    }
                m_ch.endSection("HEADER");
  }

  final public void variable() throws ParseException {
        Token tok;
        AttributesAdapter attr = new AttributesAdapter();
    tok = jj_consume_token(TOKEN_9);
                attr.add(tok);
                attr.setFirstParsedLine(tok.beginLine);
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TOKEN_X:
        ;
        break;
      default:
        jj_la1[3] = jj_gen;
        break label_3;
      }
      tok = jj_consume_token(TOKEN_X);
                           attr.add(tok);
    }
                attr.setLastParsedLine(tok.beginLine + 1);
                String name = attr.getValue(GroupCode.GC9);
                m_ch.startElement(name, attr);
                m_ch.endElement(name);
  }

// Section CLASSES -------------------------------------------------------------
  final public void sectionClasses() throws ParseException {
    jj_consume_token(S_CLASSES);
                m_ch.startSection("CLASSES");
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TOKEN_0:
        ;
        break;
      default:
        jj_la1[4] = jj_gen;
        break label_4;
      }
      aClass();
    }
                m_ch.endSection("CLASSES");
  }

  final public void aClass() throws ParseException {
        Token tok;
        AttributesAdapter attr = new AttributesAdapter();
    tok = jj_consume_token(TOKEN_0);
                attr.add(tok);
                attr.setFirstParsedLine(tok.beginLine);
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TOKEN_X:
        ;
        break;
      default:
        jj_la1[5] = jj_gen;
        break label_5;
      }
      tok = jj_consume_token(TOKEN_X);
                           attr.add(tok);
    }
                attr.setLastParsedLine(tok.beginLine + 1);
                String name = attr.getValue(GroupCode.GC1);
                m_ch.startElement(name, attr);
                m_ch.endElement(name);
  }

// Section TABLES  -------------------------------------------------------------
  final public void sectionTables() throws ParseException {
        String name;
    jj_consume_token(S_TABLES);
                m_ch.startSection("TABLES");
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TABLE_START:
        ;
        break;
      default:
        jj_la1[6] = jj_gen;
        break label_6;
      }
      name = tableStart();
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TOKEN_0:
          ;
          break;
        default:
          jj_la1[7] = jj_gen;
          break label_7;
        }
        tableEntry();
      }
      tableEnd(name);
    }
                m_ch.endSection("TABLES");
  }

  final public String tableStart() throws ParseException {
        Token tok;
        AttributesAdapter attr = new AttributesAdapter();
    tok = jj_consume_token(TABLE_START);
                attr.add(tok);
                attr.setFirstParsedLine(tok.beginLine);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TOKEN_X:
        ;
        break;
      default:
        jj_la1[8] = jj_gen;
        break label_8;
      }
      tok = jj_consume_token(TOKEN_X);
                           attr.add(tok);
    }
                attr.setLastParsedLine(tok.beginLine + 1);
                String val5 = attr.valueExists(GroupCode.GC5) ?
                        attr.getValue(GroupCode.GC5) : "null";
                String name = attr.getValue(GroupCode.GC2) + "@" + val5;
                m_ch.startTable(name, attr);
                {if (true) return name;}
    throw new Error("Missing return statement in function");
  }

  final public void tableEnd(String name) throws ParseException {
        Token tok;
    jj_consume_token(TABLE_END);
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TOKEN_X:
        ;
        break;
      default:
        jj_la1[9] = jj_gen;
        break label_9;
      }
      jj_consume_token(TOKEN_X);
    }
                m_ch.endTable(name);
  }

  final public void tableEntry() throws ParseException {
        Token tok;
        AttributesAdapter attr = new AttributesAdapter();
    tok = jj_consume_token(TOKEN_0);
                attr.add(tok);
                attr.setFirstParsedLine(tok.beginLine);
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TOKEN_9:
      case TOKEN_X:
        ;
        break;
      default:
        jj_la1[10] = jj_gen;
        break label_10;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TOKEN_9:
        tok = jj_consume_token(TOKEN_9);
        break;
      case TOKEN_X:
        tok = jj_consume_token(TOKEN_X);
                                             attr.add(tok);
        break;
      default:
        jj_la1[11] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
                attr.setLastParsedLine(tok.beginLine + 1);
                String type = attr.getValue(GroupCode.GC0);
                String val5 = attr.valueExists(GroupCode.GC5) ?
                        attr.getValue(GroupCode.GC5) : "null";
                String handle = type.equals("DIMSTYLE") ?
                        attr.getValue(GroupCode.GC105, val5) : val5;
                String name = type + "@" + handle;
                m_ch.startElement(name, attr);
                m_ch.endElement(name);
  }

// Section BLOCKS --------------------------------------------------------------
  final public void sectionBlocks() throws ParseException {
        String val;
    jj_consume_token(S_BLOCKS);
                m_ch.startSection("BLOCKS");
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BLK_START:
        ;
        break;
      default:
        jj_la1[12] = jj_gen;
        break label_11;
      }
      blockStart();
      label_12:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TOKEN_0:
          ;
          break;
        default:
          jj_la1[13] = jj_gen;
          break label_12;
        }
        entity();
      }
      blockEnd();
    }
                m_ch.endSection("BLOCKS");
  }

  final public void blockStart() throws ParseException {
        Token tok;
        AttributesAdapter attr = new AttributesAdapter();
    tok = jj_consume_token(BLK_START);
                attr.add(tok);
                attr.setFirstParsedLine(tok.beginLine);
    label_13:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TOKEN_X:
        ;
        break;
      default:
        jj_la1[14] = jj_gen;
        break label_13;
      }
      tok = jj_consume_token(TOKEN_X);
                           attr.add(tok);
    }
                attr.setLastParsedLine(tok.beginLine + 1);
                String val5 = attr.valueExists(GroupCode.GC5) ?
                        attr.getValue(GroupCode.GC5) : "null";
                String name = "BLOCK@" + val5;
                m_ch.startBlock(name, attr);
  }

  final public void blockEnd() throws ParseException {
        Token tok;
        AttributesAdapter attr = new AttributesAdapter();
    tok = jj_consume_token(BLK_END);
                attr.add(tok);
                attr.setFirstParsedLine(tok.beginLine);
    label_14:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TOKEN_X:
        ;
        break;
      default:
        jj_la1[15] = jj_gen;
        break label_14;
      }
      tok = jj_consume_token(TOKEN_X);
                           attr.add(tok);
    }
                attr.setLastParsedLine(tok.beginLine + 1);
                String val5 = attr.valueExists(GroupCode.GC5) ?
                        attr.getValue(GroupCode.GC5) : "null";
                String name =  "BLOCK@" + val5;
                m_ch.endBlock(name, attr);
  }

// Section ENTITIES ------------------------------------------------------------
  final public void sectionEntities() throws ParseException {
    jj_consume_token(S_ENTITIES);
                m_ch.startSection("ENTITIES");
    label_15:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TOKEN_0:
        ;
        break;
      default:
        jj_la1[16] = jj_gen;
        break label_15;
      }
      entity();
    }
                m_ch.endSection("ENTITIES");
  }

  final public void entity() throws ParseException {
        Token tok;
        AttributesAdapter attr = new AttributesAdapter();
    tok = jj_consume_token(TOKEN_0);
                attr.add(tok);
                attr.setFirstParsedLine(tok.beginLine);
    label_16:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TOKEN_X:
        ;
        break;
      default:
        jj_la1[17] = jj_gen;
        break label_16;
      }
      tok = jj_consume_token(TOKEN_X);
                           attr.add(tok);
    }
                attr.setLastParsedLine(tok.beginLine + 1);
                notifyEntity(attr);
  }

// Section OBJECTS -------------------------------------------------------------
  final public void sectionObjects() throws ParseException {
        String val;
    jj_consume_token(S_OBJECTS);
                m_ch.startSection("OBJECTS");
    label_17:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TOKEN_0:
        ;
        break;
      default:
        jj_la1[18] = jj_gen;
        break label_17;
      }
      anObject();
    }
                m_ch.endSection("OBJECTS");
  }

  final public void anObject() throws ParseException {
        Token tok;
        AttributesAdapter attr = new AttributesAdapter();
    tok = jj_consume_token(TOKEN_0);
                attr.add(tok);
                attr.setFirstParsedLine(tok.beginLine);
    label_18:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TOKEN_9:
      case TOKEN_X:
        ;
        break;
      default:
        jj_la1[19] = jj_gen;
        break label_18;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TOKEN_9:
        tok = jj_consume_token(TOKEN_9);
        break;
      case TOKEN_X:
        tok = jj_consume_token(TOKEN_X);
                                             attr.add(tok);
        break;
      default:
        jj_la1[20] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
                attr.setLastParsedLine(tok.beginLine + 1);
                String val5 = attr.valueExists(GroupCode.GC5) ?
                        attr.getValue(GroupCode.GC5) : "null";
                String name = attr.getValue(GroupCode.GC0) + "@" + val5;
                m_ch.startElement(name, attr);
                m_ch.endElement(name);
  }

// Section THUMBS --------------------------------------------------------------
  final public void sectionThumbs() throws ParseException {
    jj_consume_token(S_THUMBS);
                m_ch.startSection("THUMBNAILIMAGE");
    thumb();
                m_ch.endSection("THUMBNAILIMAGE");
  }

  final public void thumb() throws ParseException {
        Token tok;
        AttributesAdapter attr = new AttributesAdapter();
    tok = jj_consume_token(TOKEN_X);
                attr.add(tok);
                attr.setFirstParsedLine(tok.beginLine);
    label_19:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TOKEN_X:
        ;
        break;
      default:
        jj_la1[21] = jj_gen;
        break label_19;
      }
      tok = jj_consume_token(TOKEN_X);
                           attr.add(tok);
    }
                attr.setLastParsedLine(tok.beginLine + 1);
                String name = "THUMBNAILIMAGE";
                m_ch.startElement(name, attr);
                m_ch.endElement(name);
  }

  public DXFParserTokenManager token_source;
  JavaCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[22];
  static private int[] jj_la1_0;
  static {
      jj_la1_0();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x10,0x3f80,0x200000,0x400000,0x100000,0x400000,0x10000,0x100000,0x400000,0x400000,0x600000,0x600000,0x4000,0x100000,0x400000,0x400000,0x100000,0x400000,0x100000,0x600000,0x600000,0x400000,};
   }

  public DXFParser(java.io.InputStream stream) {
     this(stream, null);
  }
  public DXFParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new DXFParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 22; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 22; i++) jj_la1[i] = -1;
  }

  public DXFParser(java.io.Reader stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new DXFParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 22; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 22; i++) jj_la1[i] = -1;
  }

  public DXFParser(DXFParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 22; i++) jj_la1[i] = -1;
  }

  public void ReInit(DXFParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 22; i++) jj_la1[i] = -1;
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[23];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 22; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 23; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

}
